<!doctype html>
<html>
	<head>
		<title>learningthree.js boiler plate for three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


    <script src="libjs/three.min.js"></script>
    <script src="js/EffectComposer.js"></script>
    <script src="js/RenderPass.js"></script>
    <script src="js/ShaderPass.js"></script>
    <script src="js/copyShader.js"></script>
    <script src="js/SepiaShader.js"></script>
    <script src="js/GeometryUtils.js"></script>

		<link  href="css/main.css" rel="stylesheet"/>
	</head>
<body>
	<!-- three.js container -->
  <div id="container"></div>
	<!-- info on screen display -->
	<div id="info">
		<div class="top">
			<a href="http://learningthreejs.com/blog/2011/12/20/boilerplate-for-three-js/" target="_blank">LearningThree.js</a>
			boiler plate for
			<a href="https://github.com/mrdoob/three.js/" target="_blank">three.js</a>
		</div>
		<div class="bottom" id="inlineDoc" >
			- <i>p</i> for screenshot
		</div>
	</div>

	<!-- Adapted from https://pxwise.github.io/2015/05/31/Getting-Started-with-THREE.js.html -->

	<script id="vertexShader" type="x-shader/x-vertex">
	uniform float time;

	attribute vec3 vertexDisplacement;

	varying vec2 vUv;
	varying vec3 vNormal;
	varying vec3 vDisplacement;
	void main()	{

		vDisplacement = vertexDisplacement;
		vNormal = abs(normal);
		vUv = uv;
		
		gl_Position = projectionMatrix *
                modelViewMatrix *
                vec4(position,1.0);
	}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
	uniform float time;
	uniform sampler2D hairMap;

	varying vec2 vUv;
	varying vec3 vNormal;
	varying vec3 vDisplacement;
	void main() {

	vec4 hairColor = texture2D(hairMap, vec2(vUv.s, vUv.t));
    gl_FragColor = hairColor;
}
</script>

  <script>
  (function() {

  	var renderer = new THREE.WebGLRenderer({ antialias: true

  	});

  	renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // console.log(renderer.setSize)
    // assert(false)

  	// create a scene
    var scene = new THREE.Scene();

    // put a camera in the scene
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 1000;

    //taken from internet
    // hair texture
				texture = new THREE.Texture( generateTexture() );
				texture.needsUpdate = true;
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

    // material and shaders
    uniforms = {
    		hairMap: { type: "t", value: texture },
			time: { type: "f", value: 1.0 },
		};
    var material = new THREE.ShaderMaterial( {
			uniforms: uniforms,
			vertexShader: document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent
		});
    //var material = new THREE.LineDashedMaterial()


    // geometry 
    // https://threejs.orgexamples/?q=points#webgl_interactive_points
    //

    // other elements
    var startTime = Date.now();

    //objects
    var geometry = new THREE.BoxGeometry(700, 700, 700, 10, 10, 10);
    var bufferGeometry = new THREE.BufferGeometry().fromGeometry( geometry);


    var numberofVertices = bufferGeometry.attributes.position.count;
    	// vertex attributes

    // console.log(bufferGeometry)

    var vertexDisplacement = new Float32Array(numberofVertices * 3);
    for (var i = 0; i < vertexDisplacement.length; i++) {
    	vertexDisplacement[i] = Math.abs(Math.sin(i));
    }

    // console.log(vertexDisplacement);
    // assert(false)
    
    bufferGeometry.addAttribute('vertexDisplacement', new THREE.BufferAttribute(vertexDisplacement, 3));

   
    
    var cube = new THREE.Mesh(bufferGeometry, material);

    var vertices = THREE.GeometryUtils.randomPointsInGeometry(geometry,50000)

    var geometry1 = new THREE.BoxGeometry( 200, 200, 200, 16, 16, 16 );

    var PARTICLE_SIZE = 20;
	// var vertices = geometry1.vertices;
	// console.log(vertices)
	// assert(false)
	var positions = new Float32Array( vertices.length * 3 );
	var colors = new Float32Array( vertices.length * 3 );
	var sizes = new Float32Array( vertices.length );

    var vertex;
	var color = new THREE.Color();

	for ( var i = 0, l = vertices.length; i < l; i ++ ) {

		vertex = vertices[ i ];
		vertex.toArray( positions, i * 3 );

		color.setHSL( 0.01 + 0.1 * ( i / l ), 1.0, 0.5 );
		color.toArray( colors, i * 3 );

		sizes[ i ] = PARTICLE_SIZE * 0.5;

	}

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
	geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );


	var mesh1 = new THREE.Points(geometry, material)
	scene.add(mesh1);











    //scene.add(cube);
    
    //COMPOSER
    console.log(renderer)
    var composer = new THREE.EffectComposer(renderer);

    //Passes
    var renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);
    renderPass.renderToScreen =true;
 //    for (var i = 0; i <100; i++) {
 //    var pass1 = new THREE.ShaderPass(THREE.SepiaShader);
 //    composer.addPass(pass1);
	// }
	// var pass1 = new THREE.ShaderPass(THREE.SepiaShader);
 //    composer.addPass(pass1);
 //    pass1.renderToScreen = true;



 	//taken from internet 
 	function generateTexture() {

				var canvas = document.createElement( 'canvas' );
				canvas.width = 256;
				canvas.height = 256;

				var context = canvas.getContext( '2d' );

				for ( var i = 0; i < 20000; ++i ) {

					// r = hair 1/0
					// g = length
					// b = darkness
					context.fillStyle = "rgba(255," + Math.floor( Math.random() * 255 ) + ","+ Math.floor( Math.random() * 255 ) +",1)";
					
					context.fillRect( ( Math.random() * canvas.width ), ( Math.random() * canvas.height ), 2, 2 );
					
				}



				return canvas;

			}

    function render() {
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;

      mesh1.rotation.x += 0.01;
      mesh1.rotation.y += 0.01;
      requestAnimationFrame(render);
      var elapsedMilliseconds = Date.now() - startTime;
		var elapsedSeconds = elapsedMilliseconds / 1000.;
		uniforms.time.value = Math.sin(60. * elapsedSeconds);

		//console.log(uniforms.time.value)
		composer.render();

     // renderer.render(scene, camera);
    };

    render();

  }());
  </script>


</body>
</html>
